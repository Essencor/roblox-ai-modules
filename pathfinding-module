--[[
    SMART PATHFINDING MODULE V3
    Enhanced intelligence and stuck recovery
    
    NEW FEATURES:
    - Advanced stuck detection (velocity-based)
    - 8 recovery methods (not just 4)
    - Obstacle detection and avoidance
    - Dynamic path regeneration
    - Waypoint skipping for efficiency
    - Position history tracking
    - Smart timeout adjustments
]]

local PathfindingModule = {}

-- Services
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Configuration
local Config = {
    WaypointSpacing = 4,
    MaxPathDistance = 500,
    PathTimeout = 30,
    JumpCheckDistance = 8,
    JumpHeight = 4, -- Lowered from 7 for better detection
    StuckTimeout = 2, -- Reduced from 3
    StuckDistance = 1.5, -- Reduced from 2
    MaxStuckAttempts = 8, -- Increased from 3
    DeathRadius = 10,
    MaxDeathZones = 50,
    WaypointReachedDistance = 4,
    ShowPath = false,
    ShowWaypoints = true,
    PathColor = Color3.new(0, 1, 0),
    WaypointColor = Color3.new(1, 1, 0),
    UseSmartPathing = true,
    UseJumpOptimization = false, -- Changed to false by default - let PathfindingService handle it
    UseStuckRecovery = true,
    UseDynamicRerouting = true,
    UseObstacleDetection = true,
    MaxRetries = 3,
    VelocityCheckInterval = 0.5,
    MinVelocity = 0.5,
    WaypointSkipDistance = 6
}

-- State
local State = {
    isNavigating = false,
    currentPath = nil,
    currentWaypointIndex = 0,
    targetPosition = nil,
    startTime = 0,
    lastPosition = nil,
    lastMoveTime = 0,
    stuckCount = 0,
    visualizations = {},
    deathZones = {},
    positionHistory = {},
    lastVelocity = Vector3.new(0, 0, 0),
    consecutiveStuckFrames = 0,
    lastSuccessfulWaypoint = nil,
    rerouteAttempts = 0
}

-- Statistics
local Stats = {
    totalPaths = 0,
    successfulPaths = 0,
    failedPaths = 0,
    jumpsExecuted = 0,
    stucksRecovered = 0,
    deathsLearned = 0,
    averagePathTime = 0,
    totalPathTime = 0,
    pathsRerouted = 0,
    waypointsSkipped = 0
}

-- ===================================
-- UTILITY FUNCTIONS
-- ===================================

local function Log(message, level)
    level = level or "INFO"
    print("[Pathfinding:" .. level .. "] " .. tostring(message))
end

local function GetCharacter()
    return LocalPlayer.Character
end

local function GetHumanoid()
    local character = GetCharacter()
    return character and character:FindFirstChildOfClass("Humanoid")
end

local function GetRootPart()
    local character = GetCharacter()
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function GetDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function GetPosition(obj)
    if typeof(obj) == "Vector3" then
        return obj
    elseif typeof(obj) == "Instance" then
        if obj:IsA("Model") then
            local primaryPart = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if primaryPart then
                return primaryPart.Position
            end
        elseif obj:IsA("BasePart") then
            return obj.Position
        end
    end
    return nil
end

-- ===================================
-- VISUALIZATION
-- ===================================

local function ClearVisualizations()
    for _, visual in ipairs(State.visualizations) do
        if visual and visual.Parent then
            visual:Destroy()
        end
    end
    State.visualizations = {}
end

local function CreateWaypointMarker(position, color)
    if not Config.ShowWaypoints then return end
    
    local part = Instance.new("Part")
    part.Size = Vector3.new(1, 1, 1)
    part.Position = position
    part.Anchored = true
    part.CanCollide = false
    part.Color = color or Config.WaypointColor
    part.Material = Enum.Material.Neon
    part.Transparency = 0.5
    part.Parent = workspace
    
    table.insert(State.visualizations, part)
    
    task.delay(5, function()
        if part and part.Parent then
            part:Destroy()
        end
    end)
end

-- ===================================
-- DEATH LEARNING SYSTEM
-- ===================================

local function AddDeathZone(position)
    for _, zone in ipairs(State.deathZones) do
        if GetDistance(zone.position, position) < Config.DeathRadius then
            zone.deaths = zone.deaths + 1
            zone.lastDeath = tick()
            Log("Death zone reinforced at " .. tostring(position) .. " - " .. zone.deaths .. " deaths", "WARN")
            return
        end
    end
    
    table.insert(State.deathZones, {
        position = position,
        deaths = 1,
        radius = Config.DeathRadius,
        created = tick(),
        lastDeath = tick()
    })
    
    Stats.deathsLearned = Stats.deathsLearned + 1
    Log("New death zone learned at " .. tostring(position), "WARN")
    
    if #State.deathZones > Config.MaxDeathZones then
        table.remove(State.deathZones, 1)
    end
end

local function IsInDeathZone(position)
    for _, zone in ipairs(State.deathZones) do
        if GetDistance(zone.position, position) < zone.radius then
            return true
        end
    end
    return false
end

local function MonitorDeath()
    task.spawn(function()
        local character = GetCharacter()
        if not character then
            character = LocalPlayer.CharacterAdded:Wait()
        end
        
        local humanoid = GetHumanoid()
        if not humanoid then
            return
        end
        
        humanoid.Died:Connect(function()
            local rootPart = GetRootPart()
            if rootPart and State.isNavigating then
                AddDeathZone(rootPart.Position)
                Log("Death detected during navigation - learning from mistake", "ERROR")
            end
        end)
    end)
end

-- ===================================
-- OBSTACLE DETECTION
-- ===================================

local function RaycastCheck(origin, direction, distance)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {GetCharacter()}
    
    local result = workspace:Raycast(origin, direction * distance, raycastParams)
    return result
end

local function CheckGroundBelow(position, distance)
    distance = distance or 10
    local result = RaycastCheck(position, Vector3.new(0, -1, 0), distance)
    return result ~= nil, result
end

local function CheckObstacleAhead(currentPos, targetPos, checkDistance)
    checkDistance = checkDistance or 5
    local direction = (targetPos - currentPos).Unit
    local distance = math.min(GetDistance(currentPos, targetPos), checkDistance)
    
    local result = RaycastCheck(currentPos + Vector3.new(0, 2, 0), direction, distance)
    return result ~= nil, result
end

local function CheckJumpRequired(currentPos, nextPos)
    local heightDiff = nextPos.Y - currentPos.Y
    
    -- Only trigger high jump for significant height
    if heightDiff > 5 then
        return true, "high_jump"
    end
    
    -- Check for gaps (no ground between)
    local midpoint = (currentPos + nextPos) / 2
    local hasGround = CheckGroundBelow(midpoint, 20)
    
    if not hasGround then
        local distance = GetDistance(
            Vector3.new(currentPos.X, 0, currentPos.Z),
            Vector3.new(nextPos.X, 0, nextPos.Z)
        )
        
        -- Only gap jump for significant gaps
        if distance > 5 then
            return true, "gap_jump"
        end
    end
    
    -- Check for medium elevation (normal jump needed)
    if heightDiff > 2 and heightDiff <= 5 then
        return true, "normal"
    end
    
    return false, nil
end

-- ===================================
-- ENHANCED STUCK DETECTION
-- ===================================

local function UpdatePositionHistory()
    local rootPart = GetRootPart()
    if not rootPart then return end
    
    table.insert(State.positionHistory, {
        position = rootPart.Position,
        time = tick()
    })
    
    -- Keep only last 10 positions
    if #State.positionHistory > 10 then
        table.remove(State.positionHistory, 1)
    end
end

local function CalculateVelocity()
    local rootPart = GetRootPart()
    if not rootPart then return Vector3.new(0, 0, 0) end
    
    if State.lastPosition then
        local distance = rootPart.Position - State.lastPosition
        local velocity = distance / Config.VelocityCheckInterval
        return velocity
    end
    
    return Vector3.new(0, 0, 0)
end

local function IsStuckAdvanced()
    local rootPart = GetRootPart()
    if not rootPart then return false end
    
    local currentPos = rootPart.Position
    local timeSinceMove = tick() - State.lastMoveTime
    
    -- Check 1: Traditional distance check
    if State.lastPosition then
        local distanceMoved = GetDistance(currentPos, State.lastPosition)
        
        if distanceMoved < Config.StuckDistance and timeSinceMove > Config.StuckTimeout then
            Log("Stuck detected: Distance check (moved " .. math.floor(distanceMoved * 10) / 10 .. " studs in " .. math.floor(timeSinceMove * 10) / 10 .. "s)", "WARN")
            return true, "distance"
        end
        
        if distanceMoved > Config.StuckDistance then
            State.lastMoveTime = tick()
            State.consecutiveStuckFrames = 0
        end
    end
    
    -- Check 2: Velocity check
    local velocity = CalculateVelocity()
    local velocityMagnitude = velocity.Magnitude
    
    if velocityMagnitude < Config.MinVelocity and timeSinceMove > Config.StuckTimeout then
        State.consecutiveStuckFrames = State.consecutiveStuckFrames + 1
        
        if State.consecutiveStuckFrames > 5 then
            Log("Stuck detected: Velocity check (speed: " .. math.floor(velocityMagnitude * 100) / 100 .. ")", "WARN")
            return true, "velocity"
        end
    else
        State.consecutiveStuckFrames = 0
    end
    
    -- Check 3: Position oscillation (bouncing back and forth)
    if #State.positionHistory >= 6 then
        local recent = State.positionHistory
        local avgDistance = 0
        
        for i = #recent - 5, #recent do
            avgDistance = avgDistance + GetDistance(recent[i].position, currentPos)
        end
        avgDistance = avgDistance / 6
        
        if avgDistance < 3 and timeSinceMove > Config.StuckTimeout * 1.5 then
            Log("Stuck detected: Oscillation (bouncing in " .. math.floor(avgDistance * 10) / 10 .. " stud radius)", "WARN")
            return true, "oscillation"
        end
    end
    
    -- Check 4: Humanoid state
    local humanoid = GetHumanoid()
    if humanoid then
        local state = humanoid:GetState()
        if state == Enum.HumanoidStateType.Physics or 
           state == Enum.HumanoidStateType.Ragdoll or
           state == Enum.HumanoidStateType.FallingDown then
            if timeSinceMove > 2 then
                Log("Stuck detected: Abnormal humanoid state (" .. tostring(state) .. ")", "WARN")
                return true, "state"
            end
        end
    end
    
    State.lastPosition = currentPos
    State.lastVelocity = velocity
    return false, nil
end

-- ===================================
-- ENHANCED STUCK RECOVERY (8 METHODS)
-- ===================================

local function RecoverFromStuck(stuckType)
    Log("Attempting stuck recovery (type: " .. tostring(stuckType) .. ")...", "WARN")
    Stats.stucksRecovered = Stats.stucksRecovered + 1
    State.stuckCount = State.stuckCount + 1
    
    local rootPart = GetRootPart()
    local humanoid = GetHumanoid()
    if not rootPart or not humanoid then return false end
    
    local recoveryMethod = ((State.stuckCount - 1) % 8) + 1
    
    if recoveryMethod == 1 then
        -- Jump
        Log("Recovery 1/8: Jump")
        for i = 1, 2 do
            humanoid.Jump = true
            task.wait(0.2)
        end
        
    elseif recoveryMethod == 2 then
        -- Move backwards
        Log("Recovery 2/8: Move backwards")
        local backwardPos = rootPart.Position - rootPart.CFrame.LookVector * 6
        humanoid:MoveTo(backwardPos)
        task.wait(1)
        
    elseif recoveryMethod == 3 then
        -- Move to side (right)
        Log("Recovery 3/8: Move right")
        local sidePos = rootPart.Position + rootPart.CFrame.RightVector * 6
        humanoid:MoveTo(sidePos)
        task.wait(1)
        
    elseif recoveryMethod == 4 then
        -- Move to side (left)
        Log("Recovery 4/8: Move left")
        local sidePos = rootPart.Position - rootPart.CFrame.RightVector * 6
        humanoid:MoveTo(sidePos)
        task.wait(1)
        
    elseif recoveryMethod == 5 then
        -- Teleport up
        Log("Recovery 5/8: Teleport up")
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 4, 0)
        task.wait(0.5)
        
    elseif recoveryMethod == 6 then
        -- Jump backwards
        Log("Recovery 6/8: Jump backwards")
        humanoid.Jump = true
        task.wait(0.1)
        local backwardPos = rootPart.Position - rootPart.CFrame.LookVector * 8
        humanoid:MoveTo(backwardPos)
        task.wait(1)
        
    elseif recoveryMethod == 7 then
        -- Rotate and move
        Log("Recovery 7/8: Rotate 90Â° and move")
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(90), 0)
        task.wait(0.2)
        local forwardPos = rootPart.Position + rootPart.CFrame.LookVector * 5
        humanoid:MoveTo(forwardPos)
        task.wait(1)
        
    else
        -- Last resort: teleport back to last successful waypoint
        Log("Recovery 8/8: Teleport to last successful waypoint")
        if State.lastSuccessfulWaypoint then
            rootPart.CFrame = CFrame.new(State.lastSuccessfulWaypoint)
            task.wait(0.5)
        else
            rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 5, 0)
            task.wait(0.5)
        end
    end
    
    -- Reset stuck detection variables
    State.lastMoveTime = tick()
    State.lastPosition = rootPart.Position
    State.consecutiveStuckFrames = 0
    State.positionHistory = {}
    
    return true
end

-- ===================================
-- JUMP EXECUTION
-- ===================================

local function ExecuteJump(jumpType)
    local humanoid = GetHumanoid()
    local rootPart = GetRootPart()
    if not humanoid or not rootPart then return false end
    
    Log("Executing jump: " .. (jumpType or "normal"))
    Stats.jumpsExecuted = Stats.jumpsExecuted + 1
    
    if jumpType == "high_jump" then
        -- Multiple jumps for high obstacles
        Log("High jump: Triple jump sequence")
        humanoid.Jump = true
        task.wait(0.2)
        humanoid.Jump = true
        task.wait(0.2)
        humanoid.Jump = true
        task.wait(0.3)
        
    elseif jumpType == "gap_jump" then
        -- Single powerful jump for gaps
        Log("Gap jump: Single jump with momentum")
        humanoid.Jump = true
        task.wait(0.3)
        
    else
        -- Normal single jump
        Log("Normal jump: Single hop")
        humanoid.Jump = true
        task.wait(0.2)
    end
    
    return true
end

-- ===================================
-- PATH COMPUTATION WITH OBSTACLE AVOIDANCE
-- ===================================

local function ComputePath(startPos, endPos, useDeathAvoidance)
    if useDeathAvoidance == nil then
        useDeathAvoidance = true
    end
    
    if useDeathAvoidance and IsInDeathZone(endPos) then
        Log("Target is in death zone", "ERROR")
        return nil
    end
    
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = false,
        WaypointSpacing = Config.WaypointSpacing,
        Costs = {
            Water = 20,
            Danger = 999999
        }
    })
    
    local success, errorMsg = pcall(function()
        path:ComputeAsync(startPos, endPos)
    end)
    
    if not success then
        Log("Path computation failed: " .. tostring(errorMsg), "ERROR")
        return nil
    end
    
    if path.Status ~= Enum.PathStatus.Success then
        Log("Path status: " .. tostring(path.Status), "WARN")
        return nil
    end
    
    local waypoints = path:GetWaypoints()
    
    if #waypoints == 0 then
        Log("No waypoints generated", "ERROR")
        return nil
    end
    
    if useDeathAvoidance and Config.UseSmartPathing then
        local filteredWaypoints = {}
        for i, waypoint in ipairs(waypoints) do
            local inDeathZone = IsInDeathZone(waypoint.Position)
            if not inDeathZone then
                table.insert(filteredWaypoints, waypoint)
            else
                Log("Waypoint " .. i .. " filtered (death zone)", "WARN")
            end
        end
        
        if #filteredWaypoints < 2 then
            Log("Too many waypoints in death zones", "ERROR")
            return nil
        end
        
        waypoints = filteredWaypoints
    end
    
    Log("Path computed: " .. #waypoints .. " waypoints, distance: " .. math.floor(GetDistance(startPos, endPos)))
    
    return {
        path = path,
        waypoints = waypoints,
        distance = GetDistance(startPos, endPos)
    }
end

-- ===================================
-- WAYPOINT OPTIMIZATION
-- ===================================

local function OptimizeWaypoints(waypoints)
    if not Config.UseSmartPathing or #waypoints < 3 then
        return waypoints
    end
    
    Log("Optimizing " .. #waypoints .. " waypoints...")
    
    local optimized = {waypoints[1]}
    local minDistance = 3
    
    for i = 2, #waypoints - 1 do
        local prevPos = optimized[#optimized].Position
        local currentPos = waypoints[i].Position
        local distance = GetDistance(prevPos, currentPos)
        
        if distance >= minDistance then
            table.insert(optimized, waypoints[i])
        else
            Stats.waypointsSkipped = Stats.waypointsSkipped + 1
        end
    end
    
    table.insert(optimized, waypoints[#waypoints])
    
    Log("Waypoints optimized: " .. #waypoints .. " -> " .. #optimized)
    
    return optimized
end

-- ===================================
-- SMART WAYPOINT FOLLOWING
-- ===================================

local function CanSkipToWaypoint(currentPos, targetWaypoint, intermediateWaypoint)
    -- Check if we can skip the intermediate waypoint
    local hasObstacle = CheckObstacleAhead(currentPos, targetWaypoint.Position, 10)
    
    if not hasObstacle then
        local directDist = GetDistance(currentPos, targetWaypoint.Position)
        local intermediateDist = GetDistance(currentPos, intermediateWaypoint.Position) + 
                                 GetDistance(intermediateWaypoint.Position, targetWaypoint.Position)
        
        if directDist < intermediateDist * 0.85 then
            return true
        end
    end
    
    return false
end

local function MoveToWaypoint(waypoint, waypointIndex, totalWaypoints)
    local humanoid = GetHumanoid()
    local rootPart = GetRootPart()
    if not humanoid or not rootPart then return false end
    
    local waypointPos = waypoint.Position
    
    CreateWaypointMarker(waypointPos, Config.WaypointColor)
    
    -- Handle jump waypoints
    if waypoint.Action == Enum.PathWaypointAction.Jump then
        if Config.UseJumpOptimization then
            Log("PathfindingService jump - using custom jump")
            ExecuteJump("normal")
            task.wait(0.2)
        else
            Log("PathfindingService jump - using simple jump")
            humanoid.Jump = true
            task.wait(0.2)
        end
    end
    
    humanoid:MoveTo(waypointPos)
    
    local startTime = tick()
    local timeout = 10
    local reached = false
    local checkInterval = 0
    local lastJumpCheck = 0
    local jumpExecuted = false
    
    while tick() - startTime < timeout do
        if not State.isNavigating then
            return false
        end
        
        local currentPos = rootPart.Position
        local distance = GetDistance(currentPos, waypointPos)
        
        -- Check if reached
        if distance <= Config.WaypointReachedDistance then
            reached = true
            State.lastSuccessfulWaypoint = currentPos
            break
        end
        
        -- Continuous jump checking (every 0.5 seconds)
        if Config.UseJumpOptimization and not jumpExecuted then
            if tick() - lastJumpCheck >= 0.5 then
                local needsJump, jumpType = CheckJumpRequired(currentPos, waypointPos)
                if needsJump then
                    Log("Jump needed: " .. tostring(jumpType) .. " (distance to waypoint: " .. math.floor(distance) .. ")")
                    ExecuteJump(jumpType)
                    jumpExecuted = true
                    -- Reset move command after jump
                    task.wait(0.3)
                    humanoid:MoveTo(waypointPos)
                end
                lastJumpCheck = tick()
            end
        end
        
        -- Smart waypoint skipping
        if Config.UseSmartPathing and waypointIndex < totalWaypoints - 1 then
            local nextWaypoint = State.currentPath.waypoints[waypointIndex + 2]
            if nextWaypoint then
                local canSkip = CanSkipToWaypoint(currentPos, nextWaypoint, waypoint)
                if canSkip then
                    Log("Skipping waypoint " .. waypointIndex .. " (direct path available)")
                    Stats.waypointsSkipped = Stats.waypointsSkipped + 1
                    return true
                end
            end
        end
        
        -- Update position history every 0.5s
        checkInterval = checkInterval + 0.1
        if checkInterval >= Config.VelocityCheckInterval then
            UpdatePositionHistory()
            checkInterval = 0
        end
        
        -- Enhanced stuck detection
        if Config.UseStuckRecovery then
            local isStuck, stuckType = IsStuckAdvanced()
            if isStuck then
                if State.stuckCount >= Config.MaxStuckAttempts then
                    Log("Max stuck attempts reached", "ERROR")
                    return false
                end
                RecoverFromStuck(stuckType)
                -- Reset jump flag after recovery
                jumpExecuted = false
                lastJumpCheck = 0
            end
        end
        
        task.wait(0.1)
    end
    
    if not reached then
        Log("Waypoint " .. waypointIndex .. "/" .. totalWaypoints .. " timeout", "WARN")
    end
    
    return reached
end

-- ===================================
-- DYNAMIC PATH REROUTING
-- ===================================

local function AttemptReroute(currentPos, targetPos)
    if not Config.UseDynamicRerouting then
        return nil
    end
    
    if State.rerouteAttempts >= 3 then
        Log("Max reroute attempts reached", "ERROR")
        return nil
    end
    
    State.rerouteAttempts = State.rerouteAttempts + 1
    Stats.pathsRerouted = Stats.pathsRerouted + 1
    
    Log("Attempting reroute " .. State.rerouteAttempts .. "/3 from current position", "WARN")
    
    local newPath = ComputePath(currentPos, targetPos, true)
    
    if newPath then
        Log("Reroute successful - " .. #newPath.waypoints .. " waypoints", "INFO")
        return newPath
    end
    
    return nil
end

local function FollowPath(pathData)
    if not pathData or not pathData.waypoints then
        Log("Invalid path data", "ERROR")
        return false
    end
    
    local waypoints = OptimizeWaypoints(pathData.waypoints)
    State.currentWaypointIndex = 1
    State.currentPath = {waypoints = waypoints}
    
    Log("Following path with " .. #waypoints .. " waypoints")
    
    for i, waypoint in ipairs(waypoints) do
        if not State.isNavigating then
            Log("Navigation cancelled", "WARN")
            return false
        end
        
        State.currentWaypointIndex = i
        
        local success = MoveToWaypoint(waypoint, i, #waypoints)
        
        if not success then
            if i < #waypoints - 1 then
                Log("Failed at waypoint " .. i .. "/" .. #waypoints .. " - attempting reroute", "WARN")
                
                local rootPart = GetRootPart()
                if rootPart then
                    local newPath = AttemptReroute(rootPart.Position, State.targetPosition)
                    if newPath then
                        return FollowPath(newPath)
                    end
                end
                
                Log("Reroute failed", "ERROR")
                return false
            end
        end
        
        task.wait(0.1)
    end
    
    Log("Path completed successfully!", "INFO")
    return true
end

-- ===================================
-- MAIN NAVIGATION FUNCTION
-- ===================================

function PathfindingModule.Navigate(target, mode)
    PathfindingModule.Stop()
    
    State.stuckCount = 0
    State.lastMoveTime = tick()
    State.positionHistory = {}
    State.consecutiveStuckFrames = 0
    State.rerouteAttempts = 0
    
    local rootPart = GetRootPart()
    if not rootPart then
        Log("No character root part", "ERROR")
        return false
    end
    
    local startPos = rootPart.Position
    local endPos = GetPosition(target)
    
    if not endPos then
        Log("Invalid target", "ERROR")
        return false
    end
    
    local distance = GetDistance(startPos, endPos)
    if distance > Config.MaxPathDistance then
        Log("Target too far: " .. math.floor(distance) .. " studs", "ERROR")
        return false
    end
    
    State.isNavigating = true
    State.targetPosition = endPos
    State.startTime = tick()
    Stats.totalPaths = Stats.totalPaths + 1
    
    Log("Starting navigation, distance: " .. math.floor(distance) .. " studs")
    
    ClearVisualizations()
    
    local maxAttempts = Config.MaxRetries
    local success = false
    
    for attempt = 1, maxAttempts do
        if attempt > 1 then
            Log("Retry attempt " .. attempt .. "/" .. maxAttempts, "WARN")
            task.wait(1)
        end
        
        local pathData = ComputePath(rootPart.Position, endPos, true)
        
        if pathData then
            State.currentPath = pathData
            success = FollowPath(pathData)
            
            if success then
                break
            end
        else
            Log("Path computation failed (attempt " .. attempt .. ")", "ERROR")
        end
    end
    
    local duration = tick() - State.startTime
    State.isNavigating = false
    
    if success then
        Stats.successfulPaths = Stats.successfulPaths + 1
        Stats.totalPathTime = Stats.totalPathTime + duration
        Stats.averagePathTime = Stats.totalPathTime / Stats.successfulPaths
        Log("Navigation successful! Duration: " .. math.floor(duration) .. "s", "INFO")
    else
        Stats.failedPaths = Stats.failedPaths + 1
        Log("Navigation failed after " .. math.floor(duration) .. "s", "ERROR")
    end
    
    return success
end

-- ===================================
-- CONTROL FUNCTIONS
-- ===================================

function PathfindingModule.Stop()
    if State.isNavigating then
        Log("Stopping navigation", "INFO")
        State.isNavigating = false
        
        local humanoid = GetHumanoid()
        if humanoid then
            local rootPart = GetRootPart()
            if rootPart then
                humanoid:MoveTo(rootPart.Position)
            end
        end
    end
    
    ClearVisualizations()
end

function PathfindingModule.GetStatus()
    return {
        isNavigating = State.isNavigating,
        currentWaypoint = State.currentWaypointIndex,
        totalWaypoints = State.currentPath and #State.currentPath.waypoints or 0,
        mode = "smart",
        stuckCount = State.stuckCount,
        deathZones = #State.deathZones,
        rerouteAttempts = State.rerouteAttempts,
        stats = Stats
    }
end

function PathfindingModule.ClearLearning()
    State.deathZones = {}
    Stats.deathsLearned = 0
    Log("Learning database cleared", "INFO")
end

function PathfindingModule.SetConfig(key, value)
    if Config[key] ~= nil then
        Config[key] = value
        Log("Config updated: " .. key .. " = " .. tostring(value))
        return true
    end
    return false
end

function PathfindingModule.GetConfig()
    return Config
end

-- ===================================
-- CONFIGURATION PROFILES
-- ===================================

local Profiles = {
    Fast = {
        WaypointSpacing = 6,
        StuckTimeout = 1.5,
        UseSmartPathing = false,
        UseDynamicRerouting = false,
        UseJumpOptimization = false
    },
    Precise = {
        WaypointSpacing = 2,
        StuckTimeout = 2,
        UseSmartPathing = true,
        UseJumpOptimization = false,
        UseDynamicRerouting = true
    },
    Safe = {
        WaypointSpacing = 4,
        UseSmartPathing = true,
        UseStuckRecovery = true,
        MaxStuckAttempts = 8,
        UseDynamicRerouting = true,
        UseObstacleDetection = true,
        UseJumpOptimization = false
    },
    Obby = {
        WaypointSpacing = 3,
        UseJumpOptimization = true,  -- Only enable for obby mode
        ShowWaypoints = true,
        ShowPath = true,
        StuckTimeout = 1.5,
        MaxStuckAttempts = 8
    }
}

function PathfindingModule.LoadProfile(profileName)
    local profile = Profiles[profileName]
    if not profile then
        Log("Profile not found: " .. profileName, "ERROR")
        return false
    end
    
    for key, value in pairs(profile) do
        if Config[key] ~= nil then
            Config[key] = value
        end
    end
    
    Log("Profile loaded: " .. profileName)
    return true
end

function PathfindingModule.SmartNavigate(target)
    local rootPart = GetRootPart()
    if not rootPart then return false end
    
    local targetPos = GetPosition(target)
    if not targetPos then return false end
    
    local distance = GetDistance(rootPart.Position, targetPos)
    local heightDiff = math.abs(targetPos.Y - rootPart.Position.Y)
    
    local profile = "Precise"
    
    if heightDiff > 20 then
        profile = "Obby"
        Log("High vertical distance - using Obby profile")
    elseif distance > 200 then
        profile = "Fast"
        Log("Long distance - using Fast profile")
    else
        profile = "Safe"
        Log("Medium distance - using Safe profile")
    end
    
    PathfindingModule.LoadProfile(profile)
    return PathfindingModule.Navigate(target, "smart")
end

function PathfindingModule.ExportStatistics()
    return {
        totalPaths = Stats.totalPaths,
        successfulPaths = Stats.successfulPaths,
        failedPaths = Stats.failedPaths,
        successRate = Stats.totalPaths > 0 and (Stats.successfulPaths / Stats.totalPaths * 100) or 0,
        jumpsExecuted = Stats.jumpsExecuted,
        stucksRecovered = Stats.stucksRecovered,
        deathsLearned = Stats.deathsLearned,
        averagePathTime = Stats.averagePathTime,
        totalPathTime = Stats.totalPathTime,
        deathZones = #State.deathZones,
        pathsRerouted = Stats.pathsRerouted,
        waypointsSkipped = Stats.waypointsSkipped
    }
end

-- ===================================
-- INITIALIZATION
-- ===================================

MonitorDeath()

-- Start position history tracker
task.spawn(function()
    while true do
        if State.isNavigating then
            UpdatePositionHistory()
        end
        task.wait(Config.VelocityCheckInterval)
    end
end)

Log("Smart Pathfinding Module V3 loaded successfully!")
Log("Features: Enhanced Stuck Detection (4 methods), 8 Recovery Methods, Dynamic Rerouting, Obstacle Avoidance")
Log("Total lines: ~1050 | Max Stuck Attempts: 8 | Velocity-based detection")

return PathfindingModule
