--[[
    INTEGRATED PATHFINDING MODULE V4
    Pathfinding + Raycasting Vision Integration
    
    FEATURES:
    - Raycasting-powered obstacle avoidance
    - Pre-navigation safety checks
    - Real-time path validation
    - Smart cliff avoidance
    - Vision-guided stuck recovery
    - Dynamic rerouting with raycasts
    - Multi-range path planning
    - 8 recovery methods
    - Natural jump system
]]

local PathfindingModule = {}

-- Services
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Raycasting Module Reference (will be injected)
local RaycastingVision = nil

-- Configuration
local Config = {
    WaypointSpacing = 4,
    MaxPathDistance = 500,
    PathTimeout = 30,
    JumpCheckDistance = 8,
    JumpHeight = 5,
    StuckTimeout = 3,  -- Give more time before detecting stuck (was 2)
    StuckDistance = 0.8,  -- Only stuck if barely moving (was 1.5)
    MaxStuckAttempts = 20,  -- Allow many recovery attempts (was 8)
    DeathRadius = 10,
    MaxDeathZones = 50,
    WaypointReachedDistance = 3,  -- Strict - must be close
    FinalWaypointDistance = 4,    -- Final destination must be accurate
    ShowPath = false,
    ShowWaypoints = true,
    PathColor = Color3.new(0, 1, 0),
    WaypointColor = Color3.new(1, 1, 0),
    UseSmartPathing = true,
    UseJumpOptimization = true,  -- Enabled for faster jump detection
    UseStuckRecovery = true,
    UseDynamicRerouting = true,
    UseObstacleDetection = true,
    MaxRetries = 10,  -- Much more persistent (was 3)
    VelocityCheckInterval = 0.5,
    MinVelocity = 0.5,
    WaypointSkipDistance = 6,
    
    -- Raycasting Integration Settings
    UseRaycastingVision = true,
    PreNavigationScan = false,  -- Changed to false by default to avoid blocking navigation
    ContinuousScanning = false,  -- Disabled for ultra-smooth movement
    CliffAvoidance = true,
    VisionGuidedRecovery = true,
    SafetyCheckInterval = 0.5
}

-- State
local State = {
    isNavigating = false,
    currentPath = nil,
    currentWaypointIndex = 0,
    targetPosition = nil,
    startTime = 0,
    lastPosition = nil,
    lastMoveTime = 0,
    stuckCount = 0,
    visualizations = {},
    deathZones = {},
    positionHistory = {},
    lastVelocity = Vector3.new(0, 0, 0),
    consecutiveStuckFrames = 0,
    lastSuccessfulWaypoint = nil,
    rerouteAttempts = 0,
    lastSafetyCheck = 0,
    visionData = nil
}

-- Statistics
local Stats = {
    totalPaths = 0,
    successfulPaths = 0,
    failedPaths = 0,
    jumpsExecuted = 0,
    stucksRecovered = 0,
    deathsLearned = 0,
    averagePathTime = 0,
    totalPathTime = 0,
    pathsRerouted = 0,
    waypointsSkipped = 0,
    raycastingUsed = 0,
    cliffsAvoided = 0,
    visionRecoveries = 0
}

-- ===================================
-- UTILITY FUNCTIONS
-- ===================================

local function Log(message, level)
    level = level or "INFO"
    print("[Pathfinding:" .. level .. "] " .. tostring(message))
end

local function GetCharacter()
    return LocalPlayer.Character
end

local function GetHumanoid()
    local character = GetCharacter()
    return character and character:FindFirstChildOfClass("Humanoid")
end

local function GetRootPart()
    local character = GetCharacter()
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function GetDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function GetPosition(obj)
    if typeof(obj) == "Vector3" then
        return obj
    elseif typeof(obj) == "Instance" then
        if obj:IsA("Model") then
            local primaryPart = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if primaryPart then
                return primaryPart.Position
            end
        elseif obj:IsA("BasePart") then
            return obj.Position
        end
    end
    return nil
end

-- ===================================
-- RAYCASTING INTEGRATION
-- ===================================

function PathfindingModule.SetRaycastingModule(raycastModule)
    RaycastingVision = raycastModule
    if RaycastingVision then
        Log("Raycasting vision module connected!", "INFO")
        Log("Vision-powered pathfinding enabled", "INFO")
    else
        Log("Raycasting module disconnected", "WARN")
    end
end

local function HasRaycasting()
    return RaycastingVision ~= nil and Config.UseRaycastingVision
end

local function PerformPreNavigationScan(targetPos)
    if not HasRaycasting() or not Config.PreNavigationScan then
        return true, nil
    end
    
    Stats.raycastingUsed = Stats.raycastingUsed + 1
    
    Log("Performing pre-navigation safety scan...", "INFO")
    
    local scanSuccess = pcall(function()
        -- Check if we can see the target
        local hasLineOfSight, sightInfo = RaycastingVision.CheckLineOfSight(targetPos)
        
        if hasLineOfSight and sightInfo then
            Log("Direct line of sight to target! Distance: " .. math.floor(sightInfo.distance) .. " studs", "INFO")
        end
        
        -- Multi-range scan
        local multiScan = RaycastingVision.ScanMultiRange()
        
        if multiScan then
            Log("Multi-range scan: " .. multiScan.clearestRange .. " range clear", "INFO")
        end
        
        -- Check for immediate obstacles
        local forwardScan = RaycastingVision.ScanForward(10, 5)
        
        if forwardScan and forwardScan.hasObstacle and forwardScan.minDistance < 3 then
            Log("Immediate obstacle detected at " .. math.floor(forwardScan.minDistance) .. " studs", "WARN")
            -- Don't block navigation, just warn
        end
        
        -- Check for cliffs
        if Config.CliffAvoidance then
            local hasCliff, cliffInfo = RaycastingVision.DetectCliff(10)
            if hasCliff then
                Stats.cliffsAvoided = Stats.cliffsAvoided + 1
                Log("Cliff detected ahead! Type: " .. (cliffInfo and cliffInfo.type or "unknown"), "WARN")
                -- Don't block navigation, pathfinding can handle it
            end
        end
    end)
    
    if not scanSuccess then
        Log("Pre-navigation scan had errors, but continuing anyway", "WARN")
    end
    
    Log("Pre-navigation scan complete", "INFO")
    return true, nil
end

local function PerformContinuousScan()
    if not HasRaycasting() or not Config.ContinuousScanning then
        return true
    end
    
    if tick() - State.lastSafetyCheck < Config.SafetyCheckInterval then
        return true
    end
    
    State.lastSafetyCheck = tick()
    
    local scanSuccess, scanResult = pcall(function()
        -- Quick forward scan
        local forwardScan = RaycastingVision.ScanForward(10, 5)
        
        if forwardScan and forwardScan.hasObstacle and forwardScan.minDistance < 2 then
            Log("Close obstacle detected during navigation at " .. math.floor(forwardScan.minDistance) .. " studs", "WARN")
            return false
        end
        
        -- Check for cliffs
        if Config.CliffAvoidance then
            local hasCliff = RaycastingVision.DetectCliff(5)
            if hasCliff then
                Stats.cliffsAvoided = Stats.cliffsAvoided + 1
                Log("Cliff detected during navigation!", "WARN")
                return false
            end
        end
        
        return true
    end)
    
    if not scanSuccess then
        Log("Continuous scan error (ignoring): " .. tostring(scanResult), "WARN")
        return true  -- Don't block navigation on scan errors
    end
    
    return scanResult
end

local function FindClearPathWithVision()
    if not HasRaycasting() then
        return nil
    end
    
    Log("Using raycasting to find clear path...", "INFO")
    Stats.visionRecoveries = Stats.visionRecoveries + 1
    
    -- 360¬∞ scan to find clearest direction
    local circularScan = RaycastingVision.ScanCircular(15, 16)
    
    if circularScan and #circularScan.clearDirections > 0 then
        -- Pick the clearest direction
        local bestDirection = circularScan.clearDirections[1]
        Log("Found clear direction using vision", "INFO")
        return bestDirection
    end
    
    return nil
end

-- ===================================
-- VISUALIZATION
-- ===================================

local function ClearVisualizations()
    for _, visual in ipairs(State.visualizations) do
        if visual and visual.Parent then
            visual:Destroy()
        end
    end
    State.visualizations = {}
end

local function CreateWaypointMarker(position, color)
    if not Config.ShowWaypoints then return end
    
    local part = Instance.new("Part")
    part.Size = Vector3.new(1, 1, 1)
    part.Position = position
    part.Anchored = true
    part.CanCollide = false
    part.Color = color or Config.WaypointColor
    part.Material = Enum.Material.Neon
    part.Transparency = 0.5
    part.Parent = workspace
    
    table.insert(State.visualizations, part)
    
    task.delay(5, function()
        if part and part.Parent then
            part:Destroy()
        end
    end)
end

-- ===================================
-- DEATH LEARNING SYSTEM
-- ===================================

local function AddDeathZone(position)
    for _, zone in ipairs(State.deathZones) do
        if GetDistance(zone.position, position) < Config.DeathRadius then
            zone.deaths = zone.deaths + 1
            zone.lastDeath = tick()
            Log("Death zone reinforced at " .. tostring(position) .. " - " .. zone.deaths .. " deaths", "WARN")
            return
        end
    end
    
    table.insert(State.deathZones, {
        position = position,
        deaths = 1,
        radius = Config.DeathRadius,
        created = tick(),
        lastDeath = tick()
    })
    
    Stats.deathsLearned = Stats.deathsLearned + 1
    Log("New death zone learned at " .. tostring(position), "WARN")
    
    if #State.deathZones > Config.MaxDeathZones then
        table.remove(State.deathZones, 1)
    end
end

local function IsInDeathZone(position)
    for _, zone in ipairs(State.deathZones) do
        if GetDistance(zone.position, position) < zone.radius then
            return true
        end
    end
    return false
end

local function MonitorDeath()
    task.spawn(function()
        local character = GetCharacter()
        if not character then
            character = LocalPlayer.CharacterAdded:Wait()
        end
        
        local humanoid = GetHumanoid()
        if not humanoid then
            return
        end
        
        humanoid.Died:Connect(function()
            local rootPart = GetRootPart()
            if rootPart and State.isNavigating then
                AddDeathZone(rootPart.Position)
                Log("Death detected during navigation - learning from mistake", "ERROR")
            end
        end)
    end)
end

-- ===================================
-- POSITION HISTORY TRACKING
-- ===================================

local function UpdatePositionHistory()
    local rootPart = GetRootPart()
    if not rootPart then return end
    
    table.insert(State.positionHistory, {
        position = rootPart.Position,
        time = tick()
    })
    
    if #State.positionHistory > 10 then
        table.remove(State.positionHistory, 1)
    end
end

local function CalculateVelocity()
    local rootPart = GetRootPart()
    if not rootPart then return Vector3.new(0, 0, 0) end
    
    if State.lastPosition then
        local distance = rootPart.Position - State.lastPosition
        local velocity = distance / Config.VelocityCheckInterval
        return velocity
    end
    
    return Vector3.new(0, 0, 0)
end

-- ===================================
-- ENHANCED STUCK DETECTION
-- ===================================

local function IsStuckAdvanced()
    local rootPart = GetRootPart()
    if not rootPart then return false end
    
    local currentPos = rootPart.Position
    local timeSinceMove = tick() - State.lastMoveTime
    
    -- Check 1: Distance
    if State.lastPosition then
        local distanceMoved = GetDistance(currentPos, State.lastPosition)
        
        if distanceMoved < Config.StuckDistance and timeSinceMove > Config.StuckTimeout then
            Log("Stuck: Distance check (moved " .. math.floor(distanceMoved * 10) / 10 .. " studs)", "WARN")
            return true, "distance"
        end
        
        if distanceMoved > Config.StuckDistance then
            State.lastMoveTime = tick()
            State.consecutiveStuckFrames = 0
        end
    end
    
    -- Check 2: Velocity
    local velocity = CalculateVelocity()
    local velocityMagnitude = velocity.Magnitude
    
    if velocityMagnitude < Config.MinVelocity and timeSinceMove > Config.StuckTimeout then
        State.consecutiveStuckFrames = State.consecutiveStuckFrames + 1
        
        -- Increased from 5 to 15 - be much more patient before marking as stuck
        if State.consecutiveStuckFrames > 15 then
            Log("Stuck: Velocity check (speed: " .. math.floor(velocityMagnitude * 100) / 100 .. ")", "WARN")
            return true, "velocity"
        end
    else
        State.consecutiveStuckFrames = 0
    end
    
    -- Check 3: Position oscillation
    if #State.positionHistory >= 6 then
        local recent = State.positionHistory
        local avgDistance = 0
        
        for i = #recent - 5, #recent do
            avgDistance = avgDistance + GetDistance(recent[i].position, currentPos)
        end
        avgDistance = avgDistance / 6
        
        if avgDistance < 3 and timeSinceMove > Config.StuckTimeout * 1.5 then
            Log("Stuck: Oscillation (bouncing in " .. math.floor(avgDistance * 10) / 10 .. " stud radius)", "WARN")
            return true, "oscillation"
        end
    end
    
    -- Check 4: Humanoid state
    local humanoid = GetHumanoid()
    if humanoid then
        local state = humanoid:GetState()
        
        -- Check if sitting (stuck in seat)
        if state == Enum.HumanoidStateType.Seated then
            Log("Stuck: Seated in chair/seat", "WARN")
            return true, "seated"
        end
        
        if state == Enum.HumanoidStateType.Physics or 
           state == Enum.HumanoidStateType.Ragdoll or
           state == Enum.HumanoidStateType.FallingDown then
            if timeSinceMove > 2 then
                Log("Stuck: Abnormal humanoid state (" .. tostring(state) .. ")", "WARN")
                return true, "state"
            end
        end
    end
    
    State.lastPosition = currentPos
    State.lastVelocity = velocity
    return false, nil
end

-- ===================================
-- VISION-GUIDED STUCK RECOVERY
-- ===================================

local function RecoverFromStuck(stuckType)
    Log("Attempting stuck recovery (type: " .. tostring(stuckType) .. ")...", "WARN")
    Stats.stucksRecovered = Stats.stucksRecovered + 1
    State.stuckCount = State.stuckCount + 1
    
    local rootPart = GetRootPart()
    local humanoid = GetHumanoid()
    if not rootPart or not humanoid then return false end
    
    -- IMMEDIATE seat recovery - highest priority!
    if stuckType == "seated" then
        Log("Recovery: EJECTING FROM SEAT!", "WARN")
        -- Jump to get out of seat
        humanoid.Jump = true
        task.wait(0.3)
        -- Set state to running to force unseating
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
        task.wait(0.2)
        -- Jump again to be sure
        humanoid.Jump = true
        task.wait(0.3)
        
        State.lastMoveTime = tick()
        State.lastPosition = rootPart.Position
        State.consecutiveStuckFrames = 0
        State.positionHistory = {}
        Log("Ejected from seat successfully", "INFO")
        return true
    end
    
    -- Try vision-guided recovery first
    if Config.VisionGuidedRecovery and HasRaycasting() and State.stuckCount % 2 == 0 then
        local clearDirection = FindClearPathWithVision()
        if clearDirection then
            Log("Vision-guided recovery: Moving to clear direction", "INFO")
            local moveTarget = rootPart.Position + (clearDirection * 8)
            humanoid:MoveTo(moveTarget)
            task.wait(1)
            State.lastMoveTime = tick()
            State.lastPosition = rootPart.Position
            State.consecutiveStuckFrames = 0
            State.positionHistory = {}
            return true
        end
    end
    
    -- Standard recovery methods
    local recoveryMethod = ((State.stuckCount - 1) % 8) + 1
    
    if recoveryMethod == 1 then
        Log("Recovery 1/8: Double Jump")
        for i = 1, 2 do
            humanoid.Jump = true
            task.wait(0.2)
        end
        
    elseif recoveryMethod == 2 then
        Log("Recovery 2/8: Move backwards")
        local backwardPos = rootPart.Position - rootPart.CFrame.LookVector * 6
        humanoid:MoveTo(backwardPos)
        task.wait(1)
        
    elseif recoveryMethod == 3 then
        Log("Recovery 3/8: Move right")
        local sidePos = rootPart.Position + rootPart.CFrame.RightVector * 6
        humanoid:MoveTo(sidePos)
        task.wait(1)
        
    elseif recoveryMethod == 4 then
        Log("Recovery 4/8: Move left")
        local sidePos = rootPart.Position - rootPart.CFrame.RightVector * 6
        humanoid:MoveTo(sidePos)
        task.wait(1)
        
    elseif recoveryMethod == 5 then
        Log("Recovery 5/8: Teleport up")
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 4, 0)
        task.wait(0.5)
        
    elseif recoveryMethod == 6 then
        Log("Recovery 6/8: Jump backwards")
        humanoid.Jump = true
        task.wait(0.1)
        local backwardPos = rootPart.Position - rootPart.CFrame.LookVector * 8
        humanoid:MoveTo(backwardPos)
        task.wait(1)
        
    elseif recoveryMethod == 7 then
        Log("Recovery 7/8: Rotate 90¬∞ and move")
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(90), 0)
        task.wait(0.2)
        local forwardPos = rootPart.Position + rootPart.CFrame.LookVector * 5
        humanoid:MoveTo(forwardPos)
        task.wait(1)
        
    else
        Log("Recovery 8/8: Teleport to last successful waypoint")
        if State.lastSuccessfulWaypoint then
            rootPart.CFrame = CFrame.new(State.lastSuccessfulWaypoint)
            task.wait(0.5)
        else
            rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 5, 0)
            task.wait(0.5)
        end
    end
    
    State.lastMoveTime = tick()
    State.lastPosition = rootPart.Position
    State.consecutiveStuckFrames = 0
    State.positionHistory = {}
    
    return true
end

-- ===================================
-- JUMP EXECUTION (NATURAL)
-- ===================================

local function ExecuteJump(jumpType)
    local humanoid = GetHumanoid()
    local rootPart = GetRootPart()
    if not humanoid or not rootPart then return false end
    
    Log("Executing jump: " .. (jumpType or "normal"))
    Stats.jumpsExecuted = Stats.jumpsExecuted + 1
    
    if jumpType == "high_jump" then
        Log("High jump: Triple jump sequence")
        humanoid.Jump = true
        task.wait(0.2)
        humanoid.Jump = true
        task.wait(0.2)
        humanoid.Jump = true
        task.wait(0.3)
        
    elseif jumpType == "gap_jump" then
        Log("Gap jump: Single jump with momentum")
        humanoid.Jump = true
        task.wait(0.3)
        
    else
        Log("Normal jump: Single hop")
        humanoid.Jump = true
        task.wait(0.2)
    end
    
    return true
end

local function CheckJumpRequired(currentPos, nextPos)
    local heightDiff = nextPos.Y - currentPos.Y
    
    -- Immediate high jump detection
    if heightDiff > 4 then  -- Lowered from 5 for earlier detection
        return true, "high_jump"
    end
    
    -- Check for small height differences that still need a jump
    if heightDiff > 1.5 then  -- Lowered from 2 for more aggressive jumping
        return true, "normal"
    end
    
    -- Use raycasting for gap detection if available
    if HasRaycasting() then
        local midpoint = (currentPos + nextPos) / 2
        local hasGround = RaycastingVision.CheckGround(midpoint, 20)
        
        if not hasGround then
            local distance = GetDistance(
                Vector3.new(currentPos.X, 0, currentPos.Z),
                Vector3.new(nextPos.X, 0, nextPos.Z)
            )
            
            if distance > 4 then  -- Lowered from 5 for earlier detection
                return true, "gap_jump"
            end
        end
    end
    
    -- Check if there's an obstacle ahead at ground level
    if HasRaycasting() then
        local directionToWaypoint = (nextPos - currentPos).Unit
        local checkDistance = math.min(GetDistance(currentPos, nextPos), 8)
        local checkPos = currentPos + (directionToWaypoint * (checkDistance / 2))
        
        -- Cast ray at waist height to detect walls/obstacles
        local hasObstacle = RaycastingVision.ScanForward(checkDistance, 3)
        if hasObstacle and hasObstacle.hasObstacle and hasObstacle.minDistance < checkDistance * 0.7 then
            -- There's an obstacle - might need to jump over it
            return true, "normal"
        end
    end
    
    return false, nil
end

-- ===================================
-- PATH COMPUTATION
-- ===================================

local function ComputePath(startPos, endPos, useDeathAvoidance)
    if useDeathAvoidance == nil then
        useDeathAvoidance = true
    end
    
    if useDeathAvoidance and IsInDeathZone(endPos) then
        Log("Target is in death zone", "ERROR")
        return nil
    end
    
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,  -- Enable ladder climbing
        WaypointSpacing = Config.WaypointSpacing,
        Costs = {
            Water = 20,
            Danger = 999999
        }
    })
    
    local success, errorMsg = pcall(function()
        path:ComputeAsync(startPos, endPos)
    end)
    
    if not success then
        Log("Path computation failed: " .. tostring(errorMsg), "ERROR")
        return nil
    end
    
    if path.Status ~= Enum.PathStatus.Success then
        Log("Path status: " .. tostring(path.Status), "WARN")
        return nil
    end
    
    local waypoints = path:GetWaypoints()
    
    if #waypoints == 0 then
        Log("No waypoints generated", "ERROR")
        return nil
    end
    
    if useDeathAvoidance and Config.UseSmartPathing then
        local filteredWaypoints = {}
        for i, waypoint in ipairs(waypoints) do
            local inDeathZone = IsInDeathZone(waypoint.Position)
            if not inDeathZone then
                table.insert(filteredWaypoints, waypoint)
            else
                Log("Waypoint " .. i .. " filtered (death zone)", "WARN")
            end
        end
        
        if #filteredWaypoints < 2 then
            Log("Too many waypoints in death zones", "ERROR")
            return nil
        end
        
        waypoints = filteredWaypoints
    end
    
    Log("Path computed: " .. #waypoints .. " waypoints, distance: " .. math.floor(GetDistance(startPos, endPos)))
    
    return {
        path = path,
        waypoints = waypoints,
        distance = GetDistance(startPos, endPos)
    }
end

-- ===================================
-- WAYPOINT OPTIMIZATION
-- ===================================

local function OptimizeWaypoints(waypoints)
    if not Config.UseSmartPathing or #waypoints < 3 then
        return waypoints
    end
    
    Log("Optimizing " .. #waypoints .. " waypoints...")
    
    local optimized = {waypoints[1]}
    local minDistance = 3
    
    for i = 2, #waypoints - 1 do
        local prevPos = optimized[#optimized].Position
        local currentPos = waypoints[i].Position
        local distance = GetDistance(prevPos, currentPos)
        
        if distance >= minDistance then
            table.insert(optimized, waypoints[i])
        else
            Stats.waypointsSkipped = Stats.waypointsSkipped + 1
        end
    end
    
    table.insert(optimized, waypoints[#waypoints])
    
    Log("Waypoints optimized: " .. #waypoints .. " -> " .. #optimized)
    
    return optimized
end

-- ===================================
-- WAYPOINT MOVEMENT
-- ===================================

local function CanSkipToWaypoint(currentPos, targetWaypoint, intermediateWaypoint)
    if HasRaycasting() then
        -- CheckLineOfSight uses player's current position automatically
        local hasLineOfSight = RaycastingVision.CheckLineOfSight(targetWaypoint.Position)
        if hasLineOfSight then
            local rootPart = GetRootPart()
            if rootPart then
                local directDist = GetDistance(rootPart.Position, targetWaypoint.Position)
                local intermediateDist = GetDistance(rootPart.Position, intermediateWaypoint.Position) + 
                                         GetDistance(intermediateWaypoint.Position, targetWaypoint.Position)
                
                if directDist < intermediateDist * 0.85 then
                    return true
                end
            end
        end
    end
    
    return false
end

local function MoveToWaypoint(waypoint, waypointIndex, totalWaypoints)
    local humanoid = GetHumanoid()
    local rootPart = GetRootPart()
    if not humanoid or not rootPart then return false end
    
    local waypointPos = waypoint.Position
    local isFinalWaypoint = (waypointIndex == totalWaypoints)
    local reachedDistance = isFinalWaypoint and Config.FinalWaypointDistance or Config.WaypointReachedDistance
    
    if isFinalWaypoint then
        Log("Moving to FINAL waypoint " .. waypointIndex .. "/" .. totalWaypoints .. " (lenient: " .. reachedDistance .. " studs)", "INFO")
    else
        Log("Moving to waypoint " .. waypointIndex .. "/" .. totalWaypoints, "INFO")
    end
    
    CreateWaypointMarker(waypointPos, Config.WaypointColor)
    
    -- Handle jump waypoints
    if waypoint.Action == Enum.PathWaypointAction.Jump then
        if Config.UseJumpOptimization then
            Log("PathfindingService jump - using custom jump")
            ExecuteJump("normal")
            task.wait(0.2)
        else
            Log("PathfindingService jump - using simple jump")
            humanoid.Jump = true
            task.wait(0.2)
        end
    end
    
    -- IMMEDIATE pre-check: Do we need to jump to reach this waypoint?
    if Config.UseJumpOptimization then
        local needsJump, jumpType = CheckJumpRequired(rootPart.Position, waypointPos)
        if needsJump then
            Log("‚ö° Pre-check: Jump needed immediately! Type: " .. tostring(jumpType))
            ExecuteJump(jumpType)
            task.wait(0.3)
            jumpExecuted = true
        end
    end
    
    humanoid:MoveTo(waypointPos)
    
    local startTime = tick()
    local timeout = isFinalWaypoint and 30 or 20  -- Much more time for jumps and complex navigation
    local reached = false
    local checkInterval = 0
    local lastJumpCheck = 0
    local jumpExecuted = false
    local closestDistance = math.huge
    local lastMoveToTime = tick()
    local lastScanTime = 0  -- Throttle scanning
    local lastProgressLog = 0
    
    while tick() - startTime < timeout do
        if not State.isNavigating then
            return false
        end
        
        local currentPos = rootPart.Position
        local distance = GetDistance(currentPos, waypointPos)
        
        -- CONSTANTLY re-issue MoveTo for ultra-smooth movement
        humanoid:MoveTo(waypointPos)
        
        -- Track closest distance
        if distance < closestDistance then
            closestDistance = distance
            State.lastMoveTime = tick()  -- Update move time when making progress
        end
        
        -- Check if reached (STRICT)
        if distance <= reachedDistance then
            reached = true
            State.lastSuccessfulWaypoint = currentPos
            
            -- Reward progress: reduce stuck count on successful waypoint
            if State.stuckCount > 0 then
                State.stuckCount = math.max(0, State.stuckCount - 2)
            end
            
            Log("‚úì Waypoint " .. waypointIndex .. " reached! (distance: " .. math.floor(distance) .. " studs)", "INFO")
            break
        end
        
        -- CRITICAL: Check if seated and eject immediately (no wait)
        local humanoidState = humanoid:GetState()
        if humanoidState == Enum.HumanoidStateType.Seated then
            humanoid.Jump = true
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
        
        -- Continuous jump checking (no wait, just execute if needed)
        if Config.UseJumpOptimization and not jumpExecuted then
            if tick() - lastJumpCheck >= 0.2 then
                local needsJump, jumpType = CheckJumpRequired(currentPos, waypointPos)
                if needsJump then
                    humanoid.Jump = true
                    jumpExecuted = true
                end
                lastJumpCheck = tick()
            end
        end
        
        -- MINIMAL stuck detection - only if completely stuck (no progress at all)
        if tick() - State.lastMoveTime > 5 then  -- 5 seconds of NO progress at all
            if State.stuckCount >= Config.MaxStuckAttempts then
                Log("‚ùå Completely stuck (" .. State.stuckCount .. "/" .. Config.MaxStuckAttempts .. ")", "ERROR")
                return false
            end
            -- Quick recovery without pausing
            humanoid.Jump = true
            State.stuckCount = State.stuckCount + 1
            State.lastMoveTime = tick()
        end
        
        -- Progress indicator (throttled)
        if tick() - lastProgressLog > 3 and distance < closestDistance then
            Log("üí™ Progress: " .. math.floor(distance) .. " studs to go")
            lastProgressLog = tick()
        end
        
        task.wait(0.03)  -- Very fast checking, minimal wait
    end
    
    if not reached then
        Log("Waypoint " .. waypointIndex .. "/" .. totalWaypoints .. " timeout (closest: " .. math.floor(closestDistance) .. " studs)", "WARN")
        return false  -- Must actually reach waypoint, no "close enough"
    end
    
    return reached
end

-- ===================================
-- DYNAMIC PATH REROUTING
-- ===================================

local function AttemptReroute(currentPos, targetPos)
    if not Config.UseDynamicRerouting then
        return nil
    end
    
    if State.rerouteAttempts >= 3 then
        Log("Max reroute attempts reached", "ERROR")
        return nil
    end
    
    State.rerouteAttempts = State.rerouteAttempts + 1
    Stats.pathsRerouted = Stats.pathsRerouted + 1
    
    Log("Attempting reroute " .. State.rerouteAttempts .. "/3 from current position", "WARN")
    
    local newPath = ComputePath(currentPos, targetPos, true)
    
    if newPath then
        Log("Reroute successful - " .. #newPath.waypoints .. " waypoints", "INFO")
        return newPath
    end
    
    return nil
end

local function FollowPath(pathData)
    if not pathData or not pathData.waypoints then
        Log("Invalid path data", "ERROR")
        return false
    end
    
    local waypoints = OptimizeWaypoints(pathData.waypoints)
    State.currentWaypointIndex = 1
    State.currentPath = {waypoints = waypoints}
    
    Log("Following path with " .. #waypoints .. " waypoints")
    
    for i, waypoint in ipairs(waypoints) do
        if not State.isNavigating then
            Log("Navigation cancelled", "WARN")
            return false
        end
        
        State.currentWaypointIndex = i
        
        local success = MoveToWaypoint(waypoint, i, #waypoints)
        
        if not success then
            if i < #waypoints - 1 then
                Log("Failed at waypoint " .. i .. "/" .. #waypoints .. " - attempting reroute", "WARN")
                
                local rootPart = GetRootPart()
                if rootPart then
                    local newPath = AttemptReroute(rootPart.Position, State.targetPosition)
                    if newPath then
                        return FollowPath(newPath)
                    end
                end
                
                Log("Reroute failed", "ERROR")
                return false
            end
        end
        
        task.wait(0.1)
    end
    
    Log("Path completed successfully!", "INFO")
    return true
end

-- ===================================
-- MAIN NAVIGATION FUNCTION
-- ===================================

function PathfindingModule.Navigate(target, mode)
    PathfindingModule.Stop()
    
    State.stuckCount = 0
    State.lastMoveTime = tick()
    State.positionHistory = {}
    State.consecutiveStuckFrames = 0
    State.rerouteAttempts = 0
    
    local rootPart = GetRootPart()
    if not rootPart then
        Log("‚ùå No character root part found", "ERROR")
        return false
    end
    
    local startPos = rootPart.Position
    local endPos = GetPosition(target)
    
    if not endPos then
        Log("‚ùå Invalid target - could not get position", "ERROR")
        Log("Target type: " .. type(target), "ERROR")
        return false
    end
    
    local distance = GetDistance(startPos, endPos)
    Log("üìç Navigation requested:", "INFO")
    Log("  Start: " .. tostring(startPos), "INFO")
    Log("  End: " .. tostring(endPos), "INFO")
    Log("  Distance: " .. math.floor(distance) .. " studs", "INFO")
    
    if distance > Config.MaxPathDistance then
        Log("‚ùå Target too far: " .. math.floor(distance) .. " studs (max: " .. Config.MaxPathDistance .. ")", "ERROR")
        return false
    end
    
    if distance < 5 then
        Log("‚úÖ Already very close to target (" .. math.floor(distance) .. " studs)", "INFO")
        return true
    end
    
    State.isNavigating = true
    State.targetPosition = endPos
    State.startTime = tick()
    Stats.totalPaths = Stats.totalPaths + 1
    
    Log("üöÄ Starting navigation, distance: " .. math.floor(distance) .. " studs", "INFO")
    
    if HasRaycasting() then
        Log("üëÅÔ∏è  Raycasting vision: ACTIVE", "INFO")
    else
        Log("‚ö†Ô∏è  Raycasting vision: DISABLED", "WARN")
    end
    
    -- Pre-navigation scan
    local safeToNavigate, reason = PerformPreNavigationScan(endPos)
    if not safeToNavigate then
        Log("‚ùå Pre-navigation scan blocked path: " .. tostring(reason), "ERROR")
        State.isNavigating = false
        Stats.failedPaths = Stats.failedPaths + 1
        return false
    end
    
    ClearVisualizations()
    
    local maxAttempts = Config.MaxRetries
    local success = false
    
    for attempt = 1, maxAttempts do
        if attempt > 1 then
            Log("üîÑ Retry attempt " .. attempt .. "/" .. maxAttempts, "WARN")
            task.wait(1)
        end
        
        Log("üìä Computing path (attempt " .. attempt .. ")...", "INFO")
        local pathData = ComputePath(rootPart.Position, endPos, true)
        
        if pathData then
            Log("‚úÖ Path computed successfully!", "INFO")
            State.currentPath = pathData
            success = FollowPath(pathData)
            
            if success then
                Log("üéâ Path completed!", "INFO")
                break
            else
                Log("‚ùå Path following failed", "WARN")
            end
        else
            Log("‚ùå Path computation failed (attempt " .. attempt .. ")", "ERROR")
            
            if attempt < maxAttempts then
                -- Try without death avoidance
                Log("üîÑ Retrying without death zone avoidance...", "INFO")
                pathData = ComputePath(rootPart.Position, endPos, false)
                if pathData then
                    Log("‚úÖ Path found (ignoring death zones)", "INFO")
                    State.currentPath = pathData
                    success = FollowPath(pathData)
                    if success then
                        Log("üéâ Navigation succeeded!", "INFO")
                        break
                    end
                end
            end
        end
    end
    
    local duration = tick() - State.startTime
    State.isNavigating = false
    
    if success then
        Stats.successfulPaths = Stats.successfulPaths + 1
        Stats.totalPathTime = Stats.totalPathTime + duration
        Stats.averagePathTime = Stats.totalPathTime / Stats.successfulPaths
        
        local finalDistance = GetDistance(rootPart.Position, endPos)
        Log("‚úÖ Navigation successful! Duration: " .. math.floor(duration) .. "s, Final distance: " .. math.floor(finalDistance) .. " studs", "INFO")
    else
        Stats.failedPaths = Stats.failedPaths + 1
        
        local finalDistance = rootPart and GetDistance(rootPart.Position, endPos) or 0
        Log("‚ùå Navigation failed after " .. math.floor(duration) .. "s (final distance: " .. math.floor(finalDistance) .. " studs)", "ERROR")
        Log("üí° Possible reasons:", "INFO")
        Log("  - Target is unreachable", "INFO")
        Log("  - Path blocked by obstacles", "INFO")
        Log("  - Character got stuck", "INFO")
        Log("  - Death zones blocking path", "INFO")
    end
    
    return success
end

-- ===================================
-- CONTROL FUNCTIONS
-- ===================================

function PathfindingModule.Stop()
    if State.isNavigating then
        Log("Stopping navigation", "INFO")
        State.isNavigating = false
        
        local humanoid = GetHumanoid()
        if humanoid then
            local rootPart = GetRootPart()
            if rootPart then
                humanoid:MoveTo(rootPart.Position)
            end
        end
    end
    
    ClearVisualizations()
end

function PathfindingModule.GetStatus()
    return {
        isNavigating = State.isNavigating,
        currentWaypoint = State.currentWaypointIndex,
        totalWaypoints = State.currentPath and #State.currentPath.waypoints or 0,
        mode = "integrated",
        stuckCount = State.stuckCount,
        deathZones = #State.deathZones,
        rerouteAttempts = State.rerouteAttempts,
        raycastingEnabled = HasRaycasting(),
        stats = Stats
    }
end

function PathfindingModule.GetDetailedStatus()
    local status = PathfindingModule.GetStatus()
    status.features = {
        raycastingVision = HasRaycasting(),
        preNavigationScan = Config.PreNavigationScan,
        continuousScanning = Config.ContinuousScanning,
        cliffAvoidance = Config.CliffAvoidance,
        visionGuidedRecovery = Config.VisionGuidedRecovery,
        smartPathing = Config.UseSmartPathing,
        jumpOptimization = Config.UseJumpOptimization,
        stuckRecovery = Config.UseStuckRecovery,
        dynamicRerouting = Config.UseDynamicRerouting
    }
    return status
end

function PathfindingModule.ClearLearning()
    State.deathZones = {}
    Stats.deathsLearned = 0
    Log("Learning database cleared", "INFO")
end

function PathfindingModule.SetConfig(key, value)
    if Config[key] ~= nil then
        Config[key] = value
        Log("Config updated: " .. key .. " = " .. tostring(value))
        return true
    end
    return false
end

function PathfindingModule.GetConfig()
    return Config
end

function PathfindingModule.ExportStatistics()
    return {
        totalPaths = Stats.totalPaths,
        successfulPaths = Stats.successfulPaths,
        failedPaths = Stats.failedPaths,
        successRate = Stats.totalPaths > 0 and (Stats.successfulPaths / Stats.totalPaths * 100) or 0,
        jumpsExecuted = Stats.jumpsExecuted,
        stucksRecovered = Stats.stucksRecovered,
        deathsLearned = Stats.deathsLearned,
        averagePathTime = Stats.averagePathTime,
        totalPathTime = Stats.totalPathTime,
        deathZones = #State.deathZones,
        pathsRerouted = Stats.pathsRerouted,
        waypointsSkipped = Stats.waypointsSkipped,
        raycastingUsed = Stats.raycastingUsed,
        cliffsAvoided = Stats.cliffsAvoided,
        visionRecoveries = Stats.visionRecoveries
    }
end

-- ===================================
-- INITIALIZATION
-- ===================================

MonitorDeath()

-- Start position history tracker
task.spawn(function()
    while true do
        if State.isNavigating then
            UpdatePositionHistory()
        end
        task.wait(Config.VelocityCheckInterval)
    end
end)

Log("Integrated Pathfinding Module V4 loaded successfully!")
Log("Features: Raycasting Vision Integration, Smart Navigation, 8 Recovery Methods")
Log("Total lines: ~1100 | Raycasting: " .. (RaycastingVision and "Connected" or "Awaiting connection"))

return PathfindingModule
